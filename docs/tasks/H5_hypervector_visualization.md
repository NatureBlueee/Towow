# H5 -- 超向量空间可视化/调试工具

> Tier 2 | 依赖 A1（HDC 编码策略验证）完成
> 受众：有前端和数据可视化经验的开发者
> 创建日期：2026-02-07（2026-02-09 更新引用）
>
> **2026-02-09 更新**：V1 已包含 HDC 编码和共振检测的基线实现——`backend/towow/hdc/encoder.py`（MiniLM-L12-v2 + SimHash）和 `backend/towow/hdc/resonance.py`（汉明距离 + k* 阈值）。H5 可直接使用这些实现作为数据来源，无需等待 A1 从零构建编码函数。

---

## 为什么做这件事

通爻网络中，Agent 的"存在形式"是一个 10,000 维的二进制超向量。共振检测、信号路由、聚类效果——系统的核心行为全部发生在这个高维空间里。但人无法直接感知 10,000 维。这意味着：

- **编码质量无法直观判断**：Agent A 和 Agent B 的向量"够不够远"？bundle 操作后信息有没有被稀释？这些问题目前只能看汉明距离数字，没有直觉。
- **共振检测行为无法解释**：一条需求广播出去，为什么这 8 个 Agent 通过了共振、那 12 个没有？阈值 theta 是否合理？无法一眼看出来。
- **调试极其困难**：当系统出现意外行为（该共振的没共振、不该共振的共振了），开发者只能逐个检查数值，缺乏"全景视角"。

可视化工具解决的张力是：**让不可见的空间变得可见，让开发者能像看地图一样看 Agent 网络。**

值得注意的是，可视化本身也是"投影"的体现——将 10,000 维空间投影到 2D/3D 屏幕上，这和通爻架构中"丰富的东西通过透镜变成聚焦的东西"是同一个操作。这个工具不仅是调试手段，也是"投影"基本操作的一次具象演示。

---

## 你要回答什么问题

### 核心问题

**如何将 10,000 维二进制超向量空间中的 Agent 分布和共振行为，以交互式可视化的方式呈现给开发者，使其能直观判断编码质量和共振效果？**

### 子问题分解

**Q1（可视化需求定义）：开发者调试 HDC 系统时，需要"看到"什么？**

具体地：
- Agent 在降维空间中的分布是否合理？（相关的 Agent 是否聚在一起？不相关的是否远离？）
- 一次需求广播的"共振范围"在空间中是什么形状？哪些 Agent 落在范围内？
- bundle 操作前后，复合向量的位置如何变化？信息有没有被稀释到"中心"？
- Edge Agent 和 Service Agent（未来）的空间分布有什么区别？
- theta（共振阈值）的等值面在降维空间中长什么样？

**Q2（降维方法选择）：哪种降维方法最适合 HDC 二进制向量？**

候选方法：
- t-SNE：擅长保持局部结构（邻近关系），但全局距离不可靠
- UMAP：兼顾局部和全局结构，速度更快
- PCA：线性降维，可解释性强，但可能丢失非线性结构

需要回答：
- 对于 10,000 维二进制向量，哪种方法在保持汉明距离排序上效果最好？
- 方法的选择是否影响对"聚类效果"的视觉判断？
- 是否需要多种方法并存，让用户切换对比？

**Q3（可视化框架选择）：用什么工具实现？**

考虑因素：2D vs 3D、交互能力、性能（1000 个 Agent 规模）、开发效率。这是实现层面的选择，由做的人根据自身经验决定。

**Q4（交互设计）：开发者需要哪些交互能力来完成调试任务？**

典型调试场景：
- "我想看某个 Agent 的邻居都是谁"——需要点击/悬停查看详情
- "我想模拟一条广播，看谁会共振"——需要输入需求文本，实时显示共振范围
- "我想对比两个 Agent 的向量差异"——需要选择两个点，显示维度级别的对比
- "我想看 bundle 操作的效果"——需要选择多个子向量，显示 bundle 前后的位置变化

**Q5（调试功能）：哪些诊断信息对判断"系统是否正常工作"最有用？**

可能的诊断指标：
- 整体分布的离散度（Agent 是否过于集中或过于分散？）
- 聚类质量（语义相关的 Agent 是否自然聚类？）
- 共振通过率的空间分布（是否存在"死区"——永远不会被激活的 Agent？）
- 编码冲突检测（不相关的 Agent 汉明距离异常小？）

---

## 我们提供什么

### 通爻内部文档

| 资源 | 位置 | 与 H5 的关系 |
|------|------|-------------|
| 架构设计 Section 6.3.2 | `docs/ARCHITECTURE_DESIGN.md` L618-640 | HDC 核心原理：三个操作（绑定/捆束/相似度） |
| 架构设计 Section 6.3.4 | `docs/ARCHITECTURE_DESIGN.md` L679-716 | 编码流程：文本 -> 嵌入 -> SimHash -> 超向量 |
| 架构设计 Section 6.3.5 | `docs/ARCHITECTURE_DESIGN.md` L718-748 | Agent 画像生成与演化：`project(profile_data, lens)` |
| 架构设计 Section 6.3.6 | `docs/ARCHITECTURE_DESIGN.md` L750-762 | 共振检测流程：`similarity(H_agent, H_demand) > theta` |
| 架构设计 Section 6.3.10 | `docs/ARCHITECTURE_DESIGN.md` L809-955 | 共振阈值策略：k* 机制与 theta 计算 |
| Design Log #001 | `docs/DESIGN_LOG_001_PROJECTION_AND_SELF.md` | "自-我"与投影——理解为什么向量是"投影"而非"画像" |
| Design Log #003 | `docs/DESIGN_LOG_003_PROJECTION_AS_FUNCTION.md` | 投影即函数——Agent 是无状态投影的结果 |

### V1 HDC 实现（可立即使用）

V1 已包含 HDC 编码和共振检测的完整实现：

| 资源 | 位置 | 用途 |
|------|------|------|
| **HDC Encoder** | `backend/towow/hdc/encoder.py` | MiniLM-L12-v2 + SimHash → 10,000 维二进制超向量 |
| **Resonance 检测** | `backend/towow/hdc/resonance.py` | 汉明距离计算 + k* 阈值机制 |

H5 可以直接使用 V1 的编码函数生成超向量数据，无需等待 A1 完成。如果 A1 发现了更好的编码方法，H5 可以后续切换（编码器可插拔）。

### A1 的产出（增强依赖）

A1 完成后将提供更好的编码方法对比和推荐方案。H5 可以用 A1 的数据做更丰富的可视化对比（如 SimHash vs MinHash 在降维空间中的差异）。

### 外部参考

**降维方法：**
- van der Maaten & Hinton, "Visualizing Data using t-SNE" (JMLR, 2008)
- McInnes et al., "UMAP: Uniform Manifold Approximation and Projection" (arXiv:1802.03426, 2018)
- 注意：t-SNE/UMAP 通常用于浮点向量。对二进制向量（汉明距离度量），可能需要使用 metric="hamming" 参数

**可视化框架（候选，非限定）：**
- D3.js — 2D，高度定制化，适合自定义交互
- Three.js — 3D，WebGL 性能好，适合空间感展示
- Plotly / Dash — 快速原型，内置降维支持
- deck.gl — 大规模点云渲染（如果 Agent 数量将来远超 1000）
- Observable / Vega-Lite — 声明式，适合快速探索

**HDC 可视化先例：**
- Kleyko et al., "A Survey on Hyperdimensional Computing" (2023) 中有 HDC 空间可视化的示例
- 高维二进制空间的可视化是一个活跃的研究方向，可以参考 bioinformatics 领域的经验（基因组数据也是高维二进制）

### 已有结论（不需要从零开始的部分）

- HDC 超向量的维度已确定为 10,000（架构决策）
- 相似度度量已确定为汉明距离（架构决策）
- V1 场景规模为 1000 个 Agent（性能目标）
- 共振阈值使用 k* 机制（排序取第 k* 个，而非固定阈值）

---

## 子任务分解

### H5.1 可视化需求定义与调试场景

**问题**：开发者在调试 HDC 编码和共振检测时，到底需要看到什么？

**产出**：
- 5-8 个具体的调试场景（scenario），每个场景描述：问题是什么 -> 需要看到什么 -> 判断标准是什么
- 每个场景对应的视觉元素（点、线、区域、颜色编码、标注）
- 场景的优先级排序（哪些是"没有就无法工作"的，哪些是"有了更好"的）

**示例场景：**
```
场景：检查编码质量
  问题："前端开发"和"React"的 Agent 是否在空间中靠近？
  需要看到：两个 Agent 的位置 + 它们之间的距离标注
  判断标准：相关的 Agent 之间距离 < 平均距离的 50%
```

**依赖**：无（可在 A1 完成前启动，基于架构文档理解）

### H5.2 降维方法选型与对比实验

**问题**：哪种降维方法最适合 10,000 维二进制超向量的可视化？

**产出**：
- 在 A1 的实验数据上运行 t-SNE、UMAP、PCA 三种方法
- 定量对比：降维后的点间距离排序与原始汉明距离排序的一致性（Spearman 相关系数）
- 定性对比：视觉上哪种方法更容易识别聚类
- 推荐方案 + 理由

**依赖**：A1 的编码结果（需要真实的超向量数据）

### H5.3 基础可视化实现

**问题**：如何用 Web 技术渲染 1000 个 Agent 在降维空间中的分布？

**产出**：
- 可运行的 Web 应用（单页面）
- 功能：加载 Agent 超向量数据 -> 降维 -> 渲染散点图
- 基础交互：缩放、平移、悬停显示 Agent 信息（ID、Profile 摘要）
- 颜色编码：至少支持一种分组方式（如 agent_type、场景来源、数据源类型）
- 性能：1000 个点的渲染和交互流畅（>30fps）

**依赖**：H5.2 的降维方案选择

### H5.4 交互式调试功能

**问题**：开发者如何通过交互操作来完成 H5.1 中定义的调试场景？

**产出**：
- 点击 Agent 查看详情面板（Profile 数据、超向量统计信息、最近邻列表）
- 模拟广播：输入需求文本 -> 实时编码为超向量 -> 在空间中高亮共振范围 -> 显示通过/未通过的 Agent
- 选择两个 Agent，显示向量对比（汉明距离、维度级别差异热图）
- 调节 k*（期望响应数），实时看 theta 的变化和共振范围的扩缩

**依赖**：H5.3 基础可视化

### H5.5 Bundle 操作可视化与诊断

**问题**：bundle（捆束）操作的效果能否被直观呈现？

**产出**：
- 选择多个子向量（如 "技能1"、"技能2"、"经历1"），显示每个子向量的独立位置
- 执行 bundle 操作，动画展示复合向量的生成过程和最终位置
- 诊断：bundle 后的复合向量与各子向量的相似度（信息保留率的视觉表达）
- 诊断：随着 bundle 的子向量增多，复合向量是否向"空间中心"漂移（信息稀释的视觉信号）

**依赖**：H5.3 基础可视化 + A1 的编码函数

---

## 做完了是什么样

### 最低交付（H5.1 + H5.2 + H5.3）

一个可运行的 Web 应用，开发者打开后能看到：
- 1000 个 Agent 在 2D 降维空间中的散点分布
- 基础交互（缩放、平移、悬停查看信息）
- 颜色编码区分不同类型的 Agent

**判断标准**：
- 让一个不了解 HDC 的前端开发者打开这个工具，他能在 30 秒内看出"哪些 Agent 聚在一起、哪些远离"
- 开发者能用肉眼判断"编码后的空间分布是否合理"（相关的 Agent 是否真的靠近）

### 完整交付（H5.1 ~ H5.5）

在最低交付基础上，增加：
- 模拟广播和共振范围可视化
- Agent 对比和向量差异分析
- bundle 操作效果的动画展示
- 至少 3 个诊断指标的仪表板（整体离散度、聚类质量、共振通过率分布）

**判断标准**：
- 开发者能通过这个工具独立完成以下调试任务，无需查看原始数值：
  1. 判断某个 Agent 的编码是否合理（位置是否"说得通"）
  2. 判断一次共振检测的结果是否正确（通过/未通过的划分是否合理）
  3. 发现编码异常（不相关的 Agent 异常接近、相关的 Agent 异常远离）
- 工具的交互响应时间 < 200ms（用户无感知延迟）

### 做得出色（产生额外价值）

- 可视化工具本身成为通爻的"投影即函数"概念的最佳演示——10,000D → 2D 的投影过程让人直观理解"丰富→透镜→聚焦"
- 发现了编码质量的可视化诊断方法——不需要看数字，一眼就能判断"这个编码有问题"
- 工具被 A1（HDC 编码验证）直接用于实验结果的可视化分析
- 降维方法对比报告本身有学术价值（HDC 二进制向量的可视化方法对比在学术界还没有系统性的研究）

### 产出格式

- **代码**：Web 应用（建议 React/Vue + 可视化框架），提交到 `tools/hypervector-viz/`
- **文档**：README.md（使用说明、数据格式要求、部署方式）
- **降维方法对比报告**：Jupyter Notebook 或 Markdown，提交到 `research/H5_visualization/`

---

## 你必须遵守的

### 数据格式约束

- 输入数据格式必须与 A1 的输出兼容：超向量为 10,000 维二进制（0/1）数组
- 相似度度量必须使用汉明距离（与架构设计一致）
- Agent 元数据至少包含 `agent_id`、`agent_type`、`source_type`（参见架构文档 Section 6.5.1 的 AgentIdentity 结构）

### 规模约束

- 必须在 1000 个 Agent 规模下流畅运行（V1 目标规模）
- 降维计算可以是离线/预计算的（不需要实时重算 t-SNE/UMAP），但交互必须实时

### 设计原则约束

- **可视化本身是一次投影**：意识到 10,000D -> 2D/3D 是有损的。不要让用户误以为 2D 图上的距离等于真实的汉明距离。在 UI 上明确标注："这是降维后的近似表示，仅供参考"
- **本质与实现分离**：降维方法和可视化框架都必须是可替换的。不要把 t-SNE 的特定行为硬编码到交互逻辑中
- **工具为调试服务，不是展示**：优先考虑调试效率，而非视觉美观。信息密度 > 视觉效果

### 不做什么

- 不需要实现 HDC 编码本身（那是 A1 的工作，H5 消费 A1 的输出）
- 不需要连接通爻后端（工具可以读取本地文件/静态数据）
- 不需要实现 Agent 管理功能（注册、删除等）
- 不需要考虑生产环境部署（这是开发者调试工具，本地运行即可）

---

## 你可以自己决定的

### 技术选型

- **可视化框架**：D3.js、Three.js、Plotly、deck.gl、Vega-Lite 或其他——选你最熟悉的
- **2D vs 3D**：根据调试场景的需要决定。2D 更简洁，3D 空间感更强。可以两者都提供
- **降维方法**：基于 H5.2 的实验结果推荐，但也可以提供多种方法的切换
- **前端框架**：React、Vue、Svelte 或纯 HTML/JS——选你最顺手的
- **编程语言**：降维计算可以用 Python（作为预处理步骤），前端用 JavaScript/TypeScript

### 范围调整

- H5.1 可以在 A1 完成之前就启动（基于架构文档理解定义需求）
- H5.4 和 H5.5 可以根据实际调试需要调整优先级
- 如果发现某个降维方法效果特别好，可以只支持一种
- 如果发现 2D 已经足够，可以不做 3D

### 额外发现

- 如果在可视化过程中发现 HDC 编码的问题（如信息稀释、聚类不明显），这本身就是重要产出，请记录
- 如果发现某种交互模式对调试特别有效（超出最初定义），欢迎添加
- 如果发现降维方法对 HDC 二进制向量有特殊的坑（如 t-SNE 在汉明距离空间下的行为异常），请在报告中指出

---

## 对接方式

### 提交位置

- 代码：`tools/hypervector-viz/`
- 降维研究：`research/H5_visualization/`

### 数据来源

- A1 完成后，从 `research/A1_HDC_encoding/` 获取编码函数和测试数据
- 如果 A1 尚未完成，可以用随机生成的 10,000 维二进制向量做框架搭建（但降维效果和调试功能需要真实数据验证）

### 建议节奏

```
H5.1（需求定义）：1 周    -- 可在 A1 完成前启动
       ↓
H5.2（降维选型）：1 周    -- 需要 A1 数据
       ↓
H5.3（基础可视化）：1-2 周
       ↓
H5.4 + H5.5（交互 + 诊断）：2 周
```

总周期约 5-6 周。可以根据 A1 的进度和个人时间灵活调整。H5.1 建议最先启动，因为它不依赖 A1，而且产出的"调试场景列表"对 A1 的验证工作也有参考价值。

### 有问题找谁

- 架构层面的问题（HDC 原理、共振检测逻辑、投影机制）：核心团队
- A1 编码实验的数据和结论：A1 任务的负责人
- 前端/可视化的技术决策：你自己决定

### 后续依赖

- H5 的产出将直接服务于 E3（核心流程端到端验证）的调试工作
- 如果 H5 做得好，可以演化为面向最终用户的"投影空间可视化"功能（但那是另一个任务）
- H5 发现的编码问题会反馈给 A1，形成"编码 -> 可视化 -> 发现问题 -> 改进编码"的闭环

---

*本 PRD 由 Task Arch Skill 设计。核心原则：定义问题，不定义方案。约束恰好够用，自由度恰好够大。*
*关联文档：ARCHITECTURE_DESIGN.md Section 6, DESIGN_LOG_001, DESIGN_LOG_003, CONTRIBUTION_TASK_CATALOG.md*
