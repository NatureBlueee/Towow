# H3 -- 开发者入门套件

> 任务编号：H3
> 状态：PRD 已完成
> 创建日期：2026-02-07
> 层级：Tier 1
> 耦合度：中（需要理解通爻核心 + 现有代码库）
> 架构韧性：高（理念层面的指导稳定，技术栈可能演化但核心模式不变）

---

## 为什么做这件事

通爻网络提出了一种根本不同的协作范式——响应范式。已经有开发者（黑客松参赛者、独立开发者、对 AI Agent 感兴趣的创业者）表达了兴趣，但他们面对的是：一份 2000+ 行的架构文档、三篇设计日志、一套还在演化中的概念体系、以及一个相对复杂的 Team Matcher 原型。

**没有起点。**

这就像走进一座图书馆，被告知"你要找的答案就在这些书里"，但没有人告诉你先看哪本、看哪一页。结果是：有兴趣的人看了一圈，不知道从哪下手，然后走了。

开发者入门套件要解决的问题是：**让一个有编程能力、对 AI Agent 感兴趣的人，在 30 分钟内理解通爻的核心模式，并能开始动手。** 不是理解全部——是理解"足够开始"的那个最小集合。

这件事的架构韧性很高：理念层面的指导（投影即函数、响应范式、协商即聚合）是通爻最稳定的层。技术栈可能变，API 可能改，但"丰富的东西通过透镜变成聚焦的东西"这个操作不会变。入门套件的内容定义在这个层面，就能跨版本有效。

---

## 你要回答什么问题

### 核心问题

**一个开发者想用通爻的理念做自己的项目，他至少需要理解什么、拥有什么、验证什么？**

### 子问题

1. **知识边界**：30 分钟内必须理解的核心知识是什么？什么可以"后面再学"？
   - 判断标准：不理解这个概念就无法写出第一行有意义的代码 → 必须知道
   - 判断标准：不理解也能跑通最小示例，只是做不到高级用法 → 后面再学

2. **概念到代码**：通爻的核心概念如何映射到可执行的代码模式？
   - "投影是函数"在代码里长什么样？
   - "需求广播 → 共振 → Offer → 聚合"在代码里是什么调用序列？
   - 哪些是协议层的（稳定的），哪些是实现层的（可替换的）？

3. **最小可运行**：比 Team Matcher 更简单的最小示例是什么？
   - 能展示核心模式（投影 → 广播 → 共振 → Offer → 聚合 → 方案）
   - 剥离所有非核心的东西（WebSocket、OAuth、复杂 UI、数据库）
   - 一个文件或几个文件就能跑

4. **场景适配**：什么样的项目适合用通爻的模式？什么样的不适合？
   - 开发者如何自测"我的场景适不适合"？
   - 哪些特征表明"这个问题用搜索范式就够了，不需要响应范式"？

---

## 我们提供什么

### 设计原则（遇到抉择时的指南针）

| # | 原则 | 一句话 | 与入门套件的关系 |
|---|------|-------|----------------|
| 0 | 最小完整单元 ≠ MVP | 找到可递归的原子，不是砍功能 | 最小示例要展示完整的协商单元 |
| 1 | 本质与实现分离 | 协议稳定，实现可换 | 区分"必须遵守的协议"和"可以替换的实现" |
| 5 | 需求 ≠ 要求 | 需求是张力，要求是假设性解法 | 理解这一点才能设计出好的 formulation |
| 7 | 投影是基本操作 | 丰富 → 透镜 → 聚焦 | 这是整个系统的"道"，一个操作解释一切 |
| 8 | 完备性 ≠ 完全性 | 连通性 > 数据量 | 不需要复制所有数据，保持连通就够 |

### 设计文档

| 文档 | 读什么 | 为什么读 |
|------|--------|---------|
| `docs/ARCHITECTURE_DESIGN.md` Section 0 | 10 条设计原则 | 知道通爻的价值观 |
| `docs/ARCHITECTURE_DESIGN.md` Section 1 | 最小完整单元 + 核心流程 | 知道一次协商从头到尾长什么样 |
| `docs/ARCHITECTURE_DESIGN.md` Section 9 | Skill 系统清单 | 知道系统中有哪些角色、谁干什么 |
| `docs/DESIGN_LOG_003_PROJECTION_AS_FUNCTION.md` | 投影即函数 | 理解核心代码模式：`project(profile_data, lens)` |
| `docs/articles/01_投影.md` | 投影概念通俗解释 | 用生活语言理解"投影"到底是什么 |

### 已有代码/原型（参考实现）

| 代码 | 位置 | 参考价值 |
|------|------|---------|
| Team Matcher 前端 | `website/app/apps/team-matcher/` | 完整的用户旅程：request → progress → proposals |
| Team Matcher 组件 | `website/components/team-matcher/` | UI 组件模式：TeamRequestForm、TeamProposalCard、SignalVisualization |
| Team Matcher 类型 | `website/lib/team-matcher/types.ts` | 核心数据结构：TeamRequest、TeamOffer、TeamProposal |
| Team Matcher API | `website/lib/team-matcher/api.ts` | 前端 API 调用模式 |
| 后端 API | `backend/app.py` | FastAPI 路由结构、Pydantic 模型 |
| 团队组合引擎 | `backend/team_composition_engine.py` | Offer → Proposal 的聚合逻辑（LLM 驱动） |
| Prompt 模板 | `backend/team_prompts.py` | 实际使用的 LLM prompt |
| WebSocket 钩子 | `website/hooks/useTeamMatching.ts` | 实时状态管理模式 |

### 工具和 Skill

| 工具 | 用途 |
|------|------|
| Arch Skill (`.claude/skills/arch/SKILL.md`) | 架构设计讨论的 AI 对话伙伴 |
| Dev Skill (`.claude/skills/towow-dev/SKILL.md`) | 工程实现的 AI 对话伙伴 |
| Task Arch Skill (`.claude/skills/task-arch/SKILL.md`) | 任务拆解和设计 |

### 概念翻译提示

入门套件的受众是开发者。以下是通爻概念到开发者语言的翻译：

| 通爻概念 | 开发者语言 | 代码等价 |
|---------|-----------|---------|
| 投影 | 特征提取 / 降维映射 | `project(profile_data, lens) -> vector` |
| 共振 | 相似度检测 / 事件匹配 | `similarity(signal_vec, agent_vec) > threshold` |
| 透镜 | 特征选择器 / 过滤条件 | `lens = { dimensions: [...], weights: {...} }` |
| 需求 formulation | 意图丰富化 / 上下文扩展 | `formulate(raw_intent, profile) -> enriched_demand` |
| Offer | Agent 的响应结果 | `generate_offer(demand, profile) -> offer` |
| Center 聚合 | 多源结果合并 + 方案生成 | `aggregate(offers[], context) -> proposal` |
| 缺口递归 | 未满足部分的子任务拆分 | `if gap: create_sub_demand(gap) -> recurse()` |
| 回声 | 行为反馈 / 结果回流 | `update_data_source(user_id, experience_data)` |
| 响应范式 vs 搜索范式 | Pub/Sub + 端侧过滤 vs 中心化查询 | 广播事件 vs `SELECT * FROM ... WHERE ...` |

---

## 子任务分解

### H3.1 -- 核心知识地图：30 分钟内理解的最小集合

**描述**：
梳理通爻的概念体系，划分为"必须先知道"、"知道更好"、"后面再学"三层。产出一张知识地图，让开发者知道自己在哪、该往哪走。

**核心工作**：
- 遍历架构文档和设计日志，提取所有概念
- 按"不理解就无法写代码"的标准做分层
- 为每个"必须先知道"的概念写一段 3-5 句的开发者友好解释（用代码类比，不用哲学术语）
- 标注概念之间的依赖关系（理解 A 才能理解 B）

**依赖**：无（第一个启动的子任务）

**交付物**：
- "必须知道"概念清单（预计 5-8 个概念）+ 每个概念的开发者语言解释
- 概念依赖图（简单的有向图，标注阅读顺序）
- "后面再学"清单 + 每项的一句话说明（"当你需要 X 时再看这个"）

---

### H3.2 -- 快速入门指南："3 步开始你的第一个通爻应用"

**描述**：
编写一份结构清晰的快速入门文档，引导开发者从"零"到"跑通最小示例"。三步结构：

1. **理解（10 分钟）**：通爻在做什么？核心模式是什么？（概念层）
2. **看懂（10 分钟）**：核心流程在代码里长什么样？（架构层）
3. **动手（10 分钟）**：跑通最小示例，修改参数，看到不同结果（实践层）

**核心工作**：
- 第一步：用 1 页纸讲清楚响应范式和投影模式，用开发者熟悉的类比（Pub/Sub、事件驱动、MapReduce）
- 第二步：画出核心流程的代码级架构图（不是概念图），标注每一步对应的函数/模块
- 第三步：指向 H3.4 的最小示例，提供运行指令和预期结果

**依赖**：H3.1（需要知识地图确定"讲什么不讲什么"）

**交付物**：
- 快速入门文档（Markdown，3000-5000 字）
- 核心流程代码级架构图（1 张，可以是 Mermaid 或 ASCII art）

---

### H3.3 -- 核心协议/API 速查卡

**描述**：
制作一份单页速查卡，涵盖通爻核心流程中每个步骤的接口定义。重点是**协议层的语义**，而非具体的 API 端点（端点会变，语义不变）。

**核心工作**：
- 定义 6 个核心事件的语义和数据结构：
  1. `demand.formulate` — 需求丰富化
  2. `demand.broadcast` — 需求广播
  3. `offer.submit` — 响应提交
  4. `plan.generate` — 方案生成
  5. `gap.identify` — 缺口识别
  6. `sub_demand.create` — 子需求创建（递归入口）
- 每个事件：输入是什么、输出是什么、谁触发、谁消费、与上下游的关系
- 当前 Team Matcher 的具体实现作为参考（但标注为"参考实现，非协议规范"）
- 4 个核心 Skill 的接口速查：DemandFormulation、OfferGeneration、CenterCoordinator、GapRecursion

**依赖**：H3.1（概念地图确定术语统一）

**交付物**：
- 速查卡（Markdown，可打印为 1-2 页 A4）
- 可选：机器可读版本（JSON Schema 或 TypeScript 接口定义）

---

### H3.4 -- 最小可运行示例

**描述**：
构建一个比 Team Matcher 简单得多的示例应用，只展示核心模式。目标是"一个文件（或极少文件）跑通核心流程"。

**设计方向**：

建议场景——**"读书会选书"**（或同等简单的场景）：
- 一个人说"我想找一本关于 X 的书来读"（需求）
- formulation 丰富化这个需求（基于这个人的阅读历史/兴趣）
- 几个"虚拟书友"各自推荐一本书（Offer）
- Center 聚合推荐，生成一个阅读方案（可能包含"你没想到的书"）

**核心工作**：
- 用最简单的方式实现核心流程（Python 脚本，不需要 Web 框架）
- Profile 数据用硬编码的字典（不需要 SecondMe/数据库）
- "共振"用最简单的关键词匹配或嵌入向量余弦相似度（不需要 HDC）
- LLM 调用用标准的 API（Anthropic/OpenAI，不需要 SecondMe Chat）
- 展示关键模式：
  - `project(profile_data, lens)` — 投影函数
  - `formulate(raw_intent, profile)` — 需求丰富化
  - `generate_offer(demand, agent_profile)` — Offer 生成
  - `aggregate(offers, context)` — 方案聚合
  - 可选：缺口检测 + 递归

**关键约束**：
- 必须能看出"响应范式"和"搜索范式"的区别——不是"搜索书籍数据库"，而是"书友主动响应"
- 必须能看到"意外发现"——推荐了一本你没想到但很合适的书
- 代码中必须有注释标注"这是协议层/这是实现层"

**依赖**：H3.1 + H3.3（知道要展示什么概念、接口长什么样）

**交付物**：
- 可运行的 Python 脚本（1-3 个文件，总计 < 500 行）
- README：环境要求、运行方式、预期输出、"试试改这些参数看看会怎样"
- 代码中的注释说明每一步对应通爻架构的哪个部分

---

### H3.5 -- 场景适配自测清单

**描述**：
设计一份自测清单，帮助开发者判断自己的项目场景是否适合用通爻的模式。

**核心工作**：
- 梳理"适合通爻"的场景特征：
  - 需求方不完全知道自己需要什么（模糊需求）
  - 供给方多元且异构（不是同质化的选项）
  - 最优方案可能是多方组合（不是单一选择）
  - "意外发现"有价值（不是纯效率场景）
  - 供给方有自主判断能力（不是被动的数据库条目）
- 梳理"不适合通爻"的场景特征：
  - 需求完全明确，搜索即可（"找一家最近的咖啡店"）
  - 供给方同质化（"找最便宜的机票"）
  - 不需要多方协商，单次匹配就够
  - 速度比质量重要（毫秒级响应场景）
- 给出 5-8 个典型场景的判断示例（适合/不适合/边界情况）

**依赖**：H3.1（概念理解）+ H3.4（通过实操建立直觉）

**交付物**：
- 自测清单（10-15 个是/否问题，回答"是"越多越适合）
- 典型场景判断示例（每个 3-5 句话）
- "如果你的场景在边界上"的建议（可以先做什么小实验来验证）

---

## 做完了是什么样

### 产出物总览

```
docs/starter-kit/                          # 入门套件根目录
├── README.md                              # 总导航（"从这里开始"）
├── 01_knowledge_map.md                    # H3.1 核心知识地图
├── 02_quickstart.md                       # H3.2 快速入门指南
├── 03_protocol_reference.md               # H3.3 核心协议速查卡
├── 04_scene_checklist.md                  # H3.5 场景适配自测清单
└── examples/
    └── minimal_negotiation/               # H3.4 最小可运行示例
        ├── README.md                      # 运行指南
        ├── main.py                        # 核心脚本
        ├── profiles.py                    # 硬编码的 Profile 数据
        └── requirements.txt               # 依赖
```

### 质量标准

**"做完了"**：
- 5 个子任务的交付物全部产出
- 最小示例可以 `python main.py` 一键运行
- 一个对通爻零了解的开发者，按照入门指南的顺序读完 + 跑完示例，能回答：
  - "通爻和普通的匹配/推荐系统有什么区别？"
  - "投影在代码里长什么样？"
  - "我的场景适不适合用通爻？"

**"做得好"**：
- 知识地图精准区分了"必须知道"和"后面再学"，没有遗漏关键概念也没有塞太多
- 快速入门的类比让开发者产生"原来是这样"的感觉，而不是"好像懂了但不知道怎么写"
- 最小示例的代码足够简单（看懂不需要 30 分钟），同时展示了核心模式的完整性
- 场景自测清单经过至少 3 个场景的验证（不是纸上谈兵）
- 速查卡的协议层定义足够抽象，换一套技术栈后仍然成立

**"做得出色"**（产生额外价值）：
- 最小示例被社区 fork 和改造，成为多个独立项目的起点
- 快速入门指南让一个"从未听过通爻"的开发者在 30 分钟内成功跑通示例并理解核心模式
- 发现了架构文档中"概念自洽但解释不清"的地方，反馈改进了架构文档本身
- 场景自测清单被验证在至少 5 个不同场景下给出正确判断（适合/不适合/边界）

---

## 你必须遵守的

### 硬性约束

1. **理念先行**：所有内容先讲"为什么"，再讲"怎么做"。开发者不理解为什么需要响应范式，就不可能正确使用它。

2. **概念层定义，不绑定 API 版本**：速查卡定义的是事件语义（`demand.formulate` 的含义和输入输出），不是具体的 HTTP 端点（`POST /api/team/request`）。具体端点可以作为"当前参考实现"标注，但不能是规范本身。

3. **最小示例必须展示完整的协商单元**：投影 → 广播 → 共振 → Offer → 聚合 → 方案。缺任何一步都不算"完整"。可以简化每一步的实现（比如共振用余弦相似度代替 HDC），但步骤不能省。

4. **概念翻译**：所有面向开发者的内容必须用开发者能理解的语言。通爻的原创术语（投影、共振、透镜、回声）首次出现时必须附带技术等价解释。

5. **诚实标注不确定性**：通爻的架构还在演化中。哪些部分是稳定的（设计原则、核心流程）、哪些可能变（具体 API、HDC 编码策略、链上执行），必须明确标注。

6. **与设计原则对齐**：
   - 投影是基本操作（原则 0.8）：所有机制都能用"丰富 → 透镜 → 聚焦"来解释
   - 本质与实现分离（原则 0.2）：明确区分协议层和实现层
   - 需求 ≠ 要求（原则 0.6）：formulation 的存在意义必须讲清楚
   - 代码保障 > Prompt 保障（原则 0.5）：最小示例中确定性逻辑用代码控制

### 不可以做的事

- 不要写成 SDK 文档（我们还没有稳定的 SDK）
- 不要假装架构已经定型（它还在演化，这是事实）
- 不要在最小示例中引入不必要的复杂性（数据库、Web 框架、认证系统）
- 不要回避"通爻不适合的场景"——帮开发者做出正确判断，比多拉一个用户更重要

---

## 你可以自己决定的

### 方法选择

- 知识地图的呈现方式（层级列表 / 思维导图 / 有向图 / 表格）
- 快速入门中的类比选择（Pub/Sub、MapReduce、事件驱动、Actor 模型...选你觉得最好懂的）
- 最小示例的具体场景（读书会选书只是建议，任何足够简单且能展示核心模式的场景都行）
- 速查卡的格式（纯 Markdown / 加 TypeScript 接口 / 加 JSON Schema）

### 范围调整

- 如果发现 5 个子任务太多，可以合并（比如把知识地图融入快速入门的第一步）
- 如果发现某个子任务需要拆得更细，可以拆
- 如果发现 Team Matcher 的某些模式值得单独提取为"最佳实践"，可以加

### 工具使用

- LLM API 选择（Anthropic / OpenAI / 其他）
- 向量嵌入模型选择（sentence-transformers / OpenAI embedding / 其他）
- 图表工具选择（Mermaid / Excalidraw / draw.io / ASCII art）

### 额外发现

- 如果在写入门套件的过程中发现架构文档中某些概念解释不清楚，请记录下来——这本身就是有价值的反馈
- 如果发现"想象中很简单但实际上很难简化"的环节，请标注——这可能指向架构设计中需要改进的地方

---

## 对接方式

### 产出提交

- 所有文档和代码提交到 `docs/starter-kit/` 目录
- 最小示例代码提交到 `docs/starter-kit/examples/minimal_negotiation/`
- 如果需要图片资源，放在 `docs/starter-kit/assets/`

### 建议节奏

| 阶段 | 子任务 | 建议用时 | 说明 |
|------|--------|---------|------|
| Week 1 | H3.1 知识地图 | 2-3 天 | 这是其他所有任务的基础 |
| Week 1 | H3.3 速查卡（初版） | 2-3 天 | 可与 H3.1 并行，定义接口语义 |
| Week 2 | H3.4 最小示例 | 3-4 天 | 核心交付物，需要动手写代码和调试 |
| Week 2 | H3.2 快速入门 | 2-3 天 | 依赖 H3.1 + H3.4，把代码和概念串起来 |
| Week 3 | H3.5 场景自测 | 2 天 | 需要代入不同场景思考 |
| Week 3 | 整合校验 | 1-2 天 | 请一个"小白"跟着走一遍，修正不通的地方 |

总计建议：**2-3 周**

### 有问题找谁

- 架构概念不确定 → 使用 Arch Skill 或联系创始人
- 代码模式不清楚 → 参考 Team Matcher 代码，或使用 Dev Skill
- 任务边界不确定 → 使用 Task Arch Skill 或重新阅读本 PRD

### 后续依赖

- **H3 → 黑客松参赛准备**：开发者用入门套件理解通爻后，可以参考 T2 模板开发独立应用
- **H3 → 共建者 Onboarding**：入门套件是新共建者理解通爻的第一站
- **H3 中的发现 → 架构文档改进**：入门套件写作过程中暴露的概念模糊点，反馈到架构文档

### 与其他 Tier 1 任务的关系

```
A5(竞品对标) ──→ 帮助 H3.2 写好"通爻和 X 有什么区别"

H3.1(知识地图) ──→ H3.2(快速入门)
       │               │
       │               ↓
       └──→ H3.3(速查卡) ──→ H3.4(最小示例) ──→ H3.5(场景自测)
                                    │
                                    ↓
                              T2(独立场景小应用模板) ──→ 黑客松参赛
```

---

*本 PRD 由 Task Arch Skill 撰写。内容定义在问题层和概念层，不绑定具体技术实现。*
*关联文档：`docs/ARCHITECTURE_DESIGN.md`, `docs/DESIGN_LOG_003_PROJECTION_AS_FUNCTION.md`, `docs/CONTRIBUTION_TASK_CATALOG.md`*
