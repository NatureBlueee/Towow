# Design Log #006: 从协商到结晶——V2 协议的核心机制重设计

> 讨论日期：2026-02-16
> 参与者：架构师 + 创始人 + 社区（平静、Mr.mai、Cogito、Boris、01王零壹EWAN）
> 状态：核心概念收敛，循环内部设计待深入
> 触发：V2 意图场实验完成后，V1 协商阶段的概念与新世界观产生根本矛盾

---

## 一句话

**V1 的"协商"是一个五阶段流水线。V2 的"结晶"是两步加一个循环：场发现 → 条件投影循环 → 收敛或递归。**

---

## 为什么 V1 的协商必须被废弃

V1 协商是一条线性流水线：Formulate → Resonate → Negotiate → Execute → Echo。其中 Negotiate 阶段的核心假设是：Center Agent 收集所有 Offer，综合分析，输出 Plan。

V2 意图场的三个实验结论击穿了这些假设：

**假设一被击穿：需求和供给是不对称的。** V2 证明 demand 和 profile 是同一种粒子——张力。不存在"需求方发起 → 供给方响应"的单向流。任何数据变动都产生张力，任何张力都可以触发结晶。V1 的 Center 只为 demand 服务，完全忽略了 profile 变化触发的协作可能。

**假设二被击穿：匹配输出是 flat list。** V2 意图场输出的是带类型标记的关系图（同向/互补/对冲），不是按相似度排序的列表。V1 Center 拿到 flat list 后试图用 LLM 重新发现关系结构——场已经做过的工作，Center 在重复做。

**假设三被击穿：协商是一个离散阶段。** V2 世界观中，场是持续流动的。把"协商"切成一个被调用的函数，与"意图液化"的连续性自相矛盾。

---

## 第一性原理推导

### 唯一概念：张力

所有参与者的共识起点。

张力来源于存在结构——高维完整的"自"与低维投影的"我"之间的差距。这个差距就是意图，就是欲望，就是动机。协议中流动的唯一实体。

- demand 是显性张力（我知道我缺什么）
- profile 是隐性张力（我是什么，意味着我在寻求什么来完成自己）
- 两者区别只在时间尺度，不在本质
- 意图场做的事：让兼容的张力互相发现
- 结晶做的事：让发现的张力互相消解

### 关系类型的逻辑完备性

两个张力向量相遇只有三种几何关系：

| 关系 | 含义 | 向量特征 |
|------|------|----------|
| 同向 | 我们的张力方向一致，互相放大 | 正点积、同符号 |
| 互补 | 我的盈余恰好填你的亏缺 | 负点积、互补符号 |
| 对冲 | 争夺同一资源或指向矛盾方向 | 竞争同一维度 |

三种关系穷尽了所有可能。"意外关联"不是第四种关系类型，而是发现路径——在低维度看不到的关系在高维度显现后，仍然归入上述三种之一。

### Agent 之间不是博弈

（来自社区讨论，特别是平静的核心修正）

博弈论的前提：自利主体 + 信息不对称 + 策略行为。Agent 不具备这三个前提。

人类多主体交互由博弈论治理（信息不对称下的策略均衡）。Agent 多主体交互由变分原理治理（信息透明下的最小势能构型）。博弈发生在人设定边界条件的时刻。变分发生在边界条件之内的整个计算过程。

**协议不替人博弈。协议在人声明的张力投影下，以最小成本计算最优构型，然后把构型交还给人决策。**

### 三层透明度

（来自 Cogito、Boris、EWAN 的修正）

Agent 之间不是完全透明的三体人。透明度分三层：

| 层 | 透明度 | 说明 |
|----|--------|------|
| 意图层 | 高度透明 | profile 和 demand 都是意图投影，场中可见 |
| 能力层 | 部分透明 | 声称的能力 ≠ 实际兑现能力 |
| 上下文层 | 不透明 | 隐藏约束、并行承诺、真实优先级 |

意图层的透明由意图场保障。能力层和上下文层的不透明不是协议要消除的问题，而是协议要接受的现实。端侧控制披露程度（渐进披露），协议在当前披露范围内求解。

这不是道德选择，是效率选择——端侧可以选择完全透明（效率至上），也可以部分透明。但更优雅的方案是先完成前置协作再渐进披露。协议设计不依赖于端侧的透明度选择。

---

## V2 协议结构：两步一循环

### 第一步：场发现（无条件投影）

一个数据变化产生新的张力粒子。意图场通过向量距离计算发现谁在它附近。输出带类型标记的邻近图。

- 执行者：意图场（已有，V2 已验证）
- LLM：否
- 输入：全局张力场中的新扰动
- 输出：局部邻近图（主体 + 距离 + 关系类型标记）
- 触发条件：任何数据变动（demand 提交、profile 更新、行为数据变化……）

这一步与 V1 的 Resonate 对应，但有根本区别：V1 只能由 demand 触发，V2 由任何张力变化触发。

### 第二步：结晶循环（条件投影迭代）

邻近图中的主体围绕触发张力进入局部空间。在这个空间里反复做条件投影，直到收敛。

```
触发张力 → 场发现邻近图 → 进入结晶循环

    ┌─→ 每个参与方做条件投影（重新表达自己）
    │         ↓
    │   催化 Agent 收集所有投影
    │         ↓
    │   组装为新的全局上下文
    │         ↓
    │   分发给所有参与方
    │         ↓
    │   收敛？─→ 是 → 结晶完成，输出承诺构型
    │        └→ 否 → 继续循环 ───┘
    │        └→ 超时/退出 → 残余回到场中 → 触发新的第一步
```

#### 条件投影（Conditional Projection）

核心发现：人并不是天生就知道自己要什么，而是看到相关的上下文后才知道自己要什么。条件投影就是这个机制的协议化。

同一个主体在不同邻近图中会做出完全不同的表达。正如一个人加入不同的俱乐部后说的话完全不同——因为上下文不同。条件投影就是：在给定邻近图的上下文条件下，主体对自己做的一次新投影。

与意图场的投影是同一个操作，只是透镜不同：
- 意图场：无条件投影（面向全场的压缩表示）
- 条件投影：有条件投影（面向特定邻近图的情境化表达）

条件投影的 LLM 作用（张力明确化）：

1. **节选**：从主体的完整上下文中提取与当前张力相关的片段
2. **推断**：发现上下文中没有显式表达但逻辑上存在的关联（"15年数学经验"→ 可能擅长量化分析）
3. **再表达**：在当前这组参与者的上下文下，重新描述自己的张力

每一轮循环都是同一个操作在更丰富的上下文下执行。第一轮只知道触发张力是什么。第二轮还知道了其他参与方的首轮投影。第三轮知道了所有人对所有人的反应。上下文单调递增，投影精度单调递增。

#### 条件投影的输出形式

协议不规定输出格式。输出形式由张力的本性决定：

**可拆分张力**（大多数具体协作场景）：输出稀疏命名向量。正值 = 盈余，负值 = 亏缺。每个维度带来源标记（explicit / inferred）和 chunk 引用。硬约束溶解为极端值的维度（时间亏缺 = -∞ 意味着绝对不能超过）。可用代码做向量运算。

```
张力向量示例（概念性，非最终格式）：
{
  "frontend_eng":  +0.9  (explicit, chunk_37),
  "ux_design":     +0.4  (inferred),
  "backend_api":   -0.8  (explicit, chunk_12),
  "time_2weeks":   -∞    (explicit, hard bound)
}
```

**不可拆分张力**（整体性、化学反应型场景）：直接使用意图场的稠密向量或自然语言。"我需要一个能一起创业的人"——无法拆分为命名维度，但意图场的稠密编码天然能处理整体性语义匹配。

两者不是两条路径，是一个连续谱。可拆分程度高 → 代码比重高 → 成本低。可拆分程度低 → LLM 比重高 → 成本高但保留信息完整性。

#### 催化 Agent

多边场景中的信息枢纽。不是求解者，不是决策者，是镜子。

为什么需要它：每个参与方只看到自己与他人的双边关系，看不到全局。催化 Agent 让全局图案可见。

每一轮循环中催化 Agent 的工作：

1. **收集**所有参与方的当轮条件投影
2. **组装**为全局上下文（不做判断，不做综合，不做决策）
3. **分发**给每个参与方

结晶不是催化 Agent 计算出来的，是所有参与方在看到彼此之后自然收敛出来的。

催化 Agent 的张力：让结晶发生。它的高维态是一个完成的构型，低维现实是一组还在液态的意图。这个差距驱动它促进反应。但它只关乎"结晶是否发生"，不关乎"晶体长什么样"。形状由参与者的张力结构决定。

生命周期：每次多边结晶临时生成一个催化 Agent，结晶完成或超时后消散。

双边场景不需要催化 Agent。两个端侧直接交换条件投影即可。

#### 收敛判定

不需要显式的收敛判定器。收敛的自然信号是：**连续两轮条件投影没有实质性变化。** 上下文已经充分时，表达不再随新信息而改变，系统到达不动点。

可用代码检测：比较前后两轮投影的语义距离（向量运算），低于阈值即收敛。

不收敛时：设置最大轮次，达到上限后将当前状态快照呈现给触发方（人），由人决定接受或放弃。

#### 递归

残余张力 = 所有参与方张力叠加后剩余的未消解部分。

如果残余向量模长小于阈值 → 结晶完成。
如果残余向量模长大于阈值 → 残余本身成为新的张力粒子，回到场中，触发新的第一步。

这不是设计出来的"子需求功能"，是同一个操作的自然重复。残余张力和原始张力在协议层面完全同构——都是粒子，都走相同的两步流程。

---

## V1 → V2 概念映射

| V1 概念 | V2 对应 | 说明 |
|---------|---------|------|
| Formulation（需求丰富化）| 消失 | 触发张力就是原始意图。丰富化在条件投影循环中自然发生——每轮上下文更丰富，表达更精确 |
| Resonance（共振匹配）| 第一步：场发现 | 从 demand-only 触发扩展为任意张力变化触发 |
| Offer（Agent 响应）| 第二步首轮：条件投影 | 不再是"对 demand 的回应"，而是"在邻近图上下文下的自我再表达" |
| Center 综合 | 催化 Agent 的上下文组装 | 从"做决策的综合者"降级为"传信息的镜子" |
| Plan（方案输出）| 收敛不动点 | 不再由 Center 生成，而是所有参与方在迭代中自然收敛 |
| 子需求递归 | 残余张力回到场中 | 从设计功能变为同一操作的自然重复 |
| 五阶段流水线 | 两步一循环 | Formulate + Resonate + Negotiate + Execute + Echo → 场发现 + 结晶循环 |

注：Execute（执行）和 Echo（回声沉淀）不在本设计日志范围内，它们是结晶完成后的下游过程，需要单独重设计。

---

## 操作统一性验证

V2 协议中每一步都应该是投影操作的某种尺度应用。验证：

| 步骤 | 丰富的东西 | 透镜 | 聚焦的结果 |
|------|-----------|------|-----------|
| 场发现 | 全局张力场 | 向量距离 | 局部邻近图 |
| 条件投影 | 主体完整上下文 | 邻近图上下文 | 情境化张力表达 |
| 催化组装 | 所有条件投影 | 触发张力 | 全局上下文 |
| 残余计算 | 叠加后的合成态 | 阈值 | 缺口张力粒子 |

全部是投影。没有引入投影之外的操作。操作统一性成立。

---

## LLM 使用边界

| 场景 | LLM | 原因 |
|------|-----|------|
| 场发现（向量距离计算）| 否 | 纯数学 |
| 条件投影（上下文节选 + 推断）| 是 | 涉及信息判断 |
| 催化 Agent 组装上下文 | 否 | 信息聚合，不做判断 |
| 收敛检测 | 否 | 向量距离比较 |
| 残余计算（可拆分张力）| 否 | 向量加法 |
| 残余计算（不可拆分张力）| 是 | 语义评估 |
| 构型呈现给人 | 是 | 输出对象是人 |

核心原则不变：能用代码保障的不用 LLM。LLM 精确投放在条件投影（每个端侧一次/轮）和最终的人类呈现上。

---

## 关于推断精度

LLM 做条件投影时会做推断——"15年数学经验"→ "可能擅长量化分析"。推断可能有误。

解决方案不在协议层，在应用层：

1. **飞轮纠正**：LLM 批量生成推断，用户在后台标记"是我 / 不是我"。纠正后数据回流 profile，越用越准。
2. **来源标记**：推断标记为 inferred，直接表达标记为 explicit。inferred 维度在匹配中降权。随着用户确认，inferred 升级为 explicit。
3. **提示词设计**：通过 prompt 约束 LLM 的推断边界——"只推断有高置信度证据链支持的关联"。
4. **未来：专用模型**：当数据量足够时，可以训练专用的张力明确化模型。但这是接口后面的实现，协议不关心。

---

## 社区讨论的关键洞察

### 平静的修正

"博弈的是人，智能体只有计算最优解。"

Agent 层没有博弈，只有约束满足。人的自利性在边界条件上进入系统（选择暴露多少张力 + 决定是否接受构型），不在计算过程中。协议不替人做决策，只展示张力空间的数学结构。

### Cogito 的修正

Agent 不是三体人。信息传递本身有损耗，模型的主观体验和信息仍然不完全。还是不完全博弈——但不完全的位置变了：不在意图层（场已解决），在能力层和上下文层。

### 01王零壹EWAN 的区分

"意图透明，上下文不可能透明。"上下文透明并不在场中，而是通过大模型交互内置的上下文。端侧逻辑决定透明度，不影响协议设计。

### Nature 的核心定义

"在意图透明上下文部分透明的情况下，多主体协作如何设计一个元逻辑，使得在通用场景下达成资源的最高效撮合。"

元逻辑不是博弈论（策略均衡），是变分原理（最小势能构型）。

---

## 概念清理记录

本次讨论中产生后被砍掉的概念，以及砍掉的原因：

| 砍掉的概念 | 原因 |
|-----------|------|
| 相变（Phase Transition）| 物理比喻，不是协议概念 |
| 直接键合 vs 催化结晶 | 本质区别只是参与方数量，不需要两个名字 |
| 构型呈现 | UI 问题，不是协议操作 |
| 兑现探测 | 是条件投影循环的自然环节，不是独立操作 |
| 二阶结构 | 就是约束满足里的冲突约束，不需要额外术语 |
| 收敛锚定 / 谢林点 | 暗含催化剂替人选择，越界了 |
| 边界条件（bounds）| 溶解在张力向量中，极端值的维度即硬约束 |
| provides / requires | 市场语言，不是张力语言。正负值已经表达了盈余和亏缺 |

**教训：概念膨胀是 AI 讨论的职业病。每个砍掉的概念都曾经看起来"有用"，但它们增加了理解成本而没有增加解释力。协议应该用最少的概念讲完所有的事。**

最终保留的概念清单：

- 张力（唯一流动实体）
- 三种关系类型：同向/互补/对冲（逻辑完备）
- 投影（唯一操作）
- 条件投影（投影在特定上下文下的应用）
- 催化 Agent（多边场景的信息枢纽）
- 残余张力（叠加后未消解的部分，触发递归）

六个概念。描述整个结晶过程。

---

## 待深入的子课题

### 子课题 1：结晶循环内部设计

条件投影的具体交互协议：每一轮的输入/输出消息格式、催化 Agent 组装上下文的规则、端侧如何决定投影的粒度和透明度。这是下一轮深入讨论的核心内容。

### 子课题 2：收敛阈值与递归条件

"残余张力大于阈值"——阈值怎么定义？是绝对值还是相对值？是固定的还是随场景自适应的？残余向量的模长计算在不可拆分张力下如何实现？

### 子课题 3：双边与多边的边界

什么条件下两个端侧可以直接结晶不需要催化 Agent？初步假设是参与方数量（2 vs 3+），但可能还有其他因素——关系图复杂度、对冲关系的存在等。

### 子课题 4：条件投影的输出格式规范

协议层不规定格式，但实现层需要一个最小规范。结构化向量和自然语言两种形式需要统一的接口设计，使得第三步的叠加操作在两种形式上都能执行。

### 子课题 5：Execute 和 Echo 的 V2 重设计

结晶完成后的执行和回声沉淀在 V2 世界观下需要重新审视。特别是回声信号如何更新 profile 从而触发新的场发现——这是飞轮闭环的关键。

---

*写于 V2 协议从线性流水线进化为两步循环的转折点。*
*概念越少，力量越大。*
