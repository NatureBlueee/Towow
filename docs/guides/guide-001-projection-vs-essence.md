# Guide 001: 投影不同 ≠ 本质不同 — 组件复用的思维指导

**日期**: 2026-02-12
**来源**: Issue 006 + PLAN-006 复盘
**适用场景**: 当系统中有多个消费方（页面、入口、客户端）使用同一个协议/数据源时

---

## 这份文档是什么

这不是技术实现指南。这是一份**思维指导**——当你遇到类似问题时，应该从哪里开始想。

如果你是一个新加入项目的 AI（或人），被分配了一个"给 X 页面做可视化"的任务，在动手之前请读完这份文档。它会帮你避免一个特定的认知陷阱。

---

## 我们犯了什么错

### 故事

我们有一个 V1 协商协议，它产生一系列事件（formulation → resonance → offers → barrier → center tool calls → plan）。

我们有两个消费这些事件的页面：
- **App Store**（`/store/[scene]`）：面向用户的产品页面
- **Negotiation**（`/negotiation`）：面向开发者的调试页面

当我们开发 Feature 004（完整的协商图谱可视化）时，只在 Negotiation 页面实现了。App Store 被完全忽略，继续使用它自己的简化版本（300x300 的小圆圈，无交互）。

与此同时，拓扑布局算法也被写了两遍——一遍在共享库里（Kahn's BFS），另一遍在 PlanView 组件里（递归 DFS）。两个不同的算法解决同一个问题，因为开发者没有意识到共享库的存在。

### 为什么会这样

开发者（包括 AI）看到两个页面，做了一个判断：

> "App Store 是场景入口 + 简化展示，Negotiation 是完整协商交互。它们是不同的东西。"

这个判断**在产品层是对的**——两个页面的目标用户、使用场景、产品定位确实不同。

但这个判断**在协议层是错的**——两个页面消费的是完全相同的事件流、完全相同的状态结构、完全相同的协商过程。

错误在于：**把产品层的差异，投射到了协议层和组件层。**

---

## 本质原则：投影不同 ≠ 本质不同

这是通爻架构设计原则 0.8 的工程推论。

### 原则 0.8 说的是什么

> 系统中每一步都是同一个操作：丰富的东西通过透镜变成聚焦的东西。

App Store 和 Negotiation 页面，是同一个协商过程通过两个不同的透镜（产品场景）的投影。

投影的**呈现方式**可以不同——一个可以有更大的图谱、一个可以有更简洁的布局。但投影的**被投影物**是同一个——协商状态。

### 在工程中意味着什么

当你看到系统中有两个看起来不同的东西，问自己：

> **它们是从同一个本质投影出来的吗？**

如果是，那么：
- **状态结构**应该共享（同一个 `NegotiationState`）
- **纯计算逻辑**应该共享（同一个布局算法、同一个状态转换函数）
- **渲染层**可以不同（不同的 CSS、不同的布局、不同的交互密度）
- **适配层**用纯函数桥接格式差异（adapter pattern）

如果不是——比如一个是协商过程、一个是用户设置页面——那它们确实是不同的东西，不应该强行复用。

### 判断方法

```
问题：A 和 B 应该共享组件吗？

Step 1: 它们消费的数据源是同一个协议/API 吗？
  - 是 → 继续 Step 2
  - 否 → 不需要共享，各自独立

Step 2: 数据的结构和语义是相同的吗？
  - 是 → 应该共享状态层和计算层
  - 部分相同 → 共享相同部分，用 adapter 桥接差异
  - 完全不同 → 不应该共享

Step 3: 呈现方式需要相同吗？
  - 是 → 共享到渲染层（直接复用组件）
  - 否 → 共享状态和计算，各自渲染
```

在 Issue 006 的案例中：
- Step 1: 是——都消费 V1 协商事件流
- Step 2: 是——完全相同的事件类型和字段
- Step 3: 用户说"是"——"这些组件本来就是为 App Store 做的"
- 结论：应该全量复用，用 adapter 桥接格式差异

---

## 第二个本质：纯计算 vs 渲染的分离

拓扑布局写了两遍的问题，揭示了另一个认知陷阱：

> **因为渲染方式不同，所以觉得计算逻辑也应该不同。**

PlanView 用 Framer Motion 做动画，TopologyView 用 CSS 动画。它们的渲染层确实不同。但布局计算（"给定一组有依赖关系的任务，算出每个任务的 x, y 坐标"）是纯数学问题，与渲染无关。

### 原则

> **纯计算逻辑必须与渲染分离，且第一次写的时候就提取到共享库。**

"纯计算"的判断标准：
- 输入是数据，输出是数据（不是 DOM、不是 JSX、不是 CSS）
- 不依赖框架（React、Vue、Svelte 都能用）
- 不依赖运行环境（浏览器、Node、Deno 都能用）

如果一段逻辑满足这三个条件，它就是纯计算，应该从第一天起就放在 `@/lib/` 作为共享函数。

不要等到"发现重复了才提取"——那时候两个版本已经开始分化了（不同的排序策略、不同的边界处理），合并成本远大于一开始就共享。

---

## 第三个本质：Feature scope 的消费方盲区

Feature 004 的 scope 定义是"给 Negotiation 页面做协商图谱可视化"。

这个 scope 定义本身就有问题——它是从**页面**的角度定义的，不是从**协议**的角度定义的。

### 正确的 scope 思维

当你要做一个功能时，问：

> **我改的是哪一层的东西？这一层有几个消费方？**

```
协议层改动 → 所有消费方都要检查
  例：改了事件 schema → App Store、Negotiation 页面、未来的 MCP 入口

基础设施层改动 → 依赖这个基础设施的都要检查
  例：改了 WebSocket pusher → 所有 WS 消费方

能力层改动 → 使用这个能力的都要检查
  例：改了 Center Skill 的输出格式 → plan 的所有展示方

应用层改动 → 通常只影响自己
  例：改了 Negotiation 页面的 CSS → 只影响这个页面
```

Feature 004 创建了一套新的可视化组件（NegotiationGraph + 子组件），这些组件消费的是**协议层的事件**。因此它的 scope 应该是：

> "为 V1 协商协议的事件流创建可视化组件体系，并接入所有消费方。"

而不是：

> "给 Negotiation 页面做图谱。"

### 消费方检查清单

每次创建或修改**协议相关的组件**时：

```
□ 列出当前所有消费方
  - 已有页面（App Store、Negotiation、未来的 MCP dashboard...）
  - 已有 hooks（useStoreNegotiation、useNegotiationStream）
  - 已有适配层（store-negotiation-adapter）

□ 这次改动对每个消费方的影响：
  - 直接受益？（应该一起改）
  - 不受影响？（确认，不是假设）
  - 需要适配？（写 adapter）

□ 如果创建了新的共享组件，每个消费方是否可以接入？
  - 数据格式是否兼容？
  - 需要什么适配？
```

---

## 解法模式：Adapter + 零修改复用

PLAN-006 最终采用的解法有一个值得记住的模式：

```
旧数据格式（StoreEvent[]）
    ↓ adapter（纯函数，~150 行）
新数据格式（NegotiationState）
    ↓
共享组件（NegotiationGraph，零修改）
```

这个模式的本质：

1. **不改共享组件**——如果共享组件需要为某个消费方做特殊处理，说明共享组件的抽象没做对
2. **不改数据源**——消费方的数据管道是既有契约，不应该为了前端复用去改后端 API
3. **用纯函数做桥接**——adapter 是无副作用的纯函数，输入 A 格式，输出 B 格式。易测试、易理解、易替换

### 什么时候用这个模式

当你发现：
- 有一个现成的组件做了你需要的事
- 但你的数据格式跟它期望的不同
- 数据的**语义**是相同的（同一个协商过程），只是**结构**不同（不同的字段名、不同的嵌套方式）

那就写一个 adapter。不要复制组件然后改它的 props，不要在组件内部加 `if (isAppStore)` 的分支。

### 什么时候不用这个模式

当两个场景的**语义**真的不同——比如一个是协商过程可视化，一个是用户个人资料展示——硬把它们塞进同一个组件反而有害。这时候各自独立是正确的。

判断的关键永远是：**本质是否相同**。

---

## 给新 AI 的检查提示

如果你被分配了一个前端可视化或组件开发任务，在写第一行代码之前：

### 1. 先问"谁消费同一个数据源"

```
我要可视化的数据来自哪里？（哪个 API / 哪种事件 / 哪个 hook）
还有谁在可视化同样的数据？
他们现在怎么做的？我能复用吗？
```

### 2. 再问"有没有现成的共享组件"

```
@/components/ 下有没有做类似事情的组件？
@/lib/ 下有没有现成的计算逻辑？
如果有，我的数据格式跟它兼容吗？需要 adapter 吗？
```

### 3. 然后问"我写的东西别人能复用吗"

```
如果我现在写一个新组件，未来有第三个消费方时，它能直接用吗？
我的组件依赖的是通用的 NegotiationState，还是特定页面的 props？
纯计算逻辑有没有放进 @/lib/？
```

### 4. 最后问"我改的是哪层，消费方有几个"

```
我改的东西属于协议层、基础设施层、能力层还是应用层？
如果不是纯应用层，有几个消费方？每个都检查了吗？
```

---

## 这份文档的本质

用一句话总结：

> **看到两个东西"长得不一样"，不要急着写两套。先问它们"是不是同一个东西的不同投影"。如果是，共享本质，适配差异。**

这就是设计原则 0.8（投影是基本操作）在日常工程中的应用。

---

## 关联文档

| 文档 | 关系 |
|------|------|
| `docs/ARCHITECTURE_DESIGN.md` Section 0.8 | 投影是基本操作（理论基础） |
| `docs/issues/006-app-store-component-duplication.md` | 问题的完整诊断 |
| `docs/decisions/PLAN-006-app-store-graph-reuse.md` | 具体的修复方案 |
| `memory/planning-lessons.md` | 接缝盲区、类型对齐≠数据流通等工程教训 |
| `docs/ARCHITECTURE_DESIGN.md` Section 0.2 | 本质与实现分离（基础原则） |
