# Design Log #005: 场景即产品——通爻的产品范式

> 讨论日期：2026-02-08
> 参与者：架构师 + 创始人
> 状态：核心概念确立，API 边界待实现验证
> 触发：架构讨论 Tasks #1-#14 全部关闭后，思考"基于通爻做的产品有没有一种范式"

---

## 核心命题

**协商单元是通用引擎，场景定义是唯一的差异化。**

一旦协商单元的 API 和事件协议定义清楚，做任何新场景的产品就变成了"配置 + UI"，而不是"从头开发"。

类比：
- HTTP 出现后：Web 应用开发从"网络工程"变成"内容创作"
- 通爻之后：产品开发从"智能工程"变成"场景定义"

---

## 传统产品 vs 通爻产品

**传统的匹配/协作产品**，每个都要自建全套：

```
用户管理 → 数据模型 → 匹配算法 → 协调逻辑 → 通知系统 → 支付 → 反馈评价 → 数据分析
```

Upwork 要建，Boss 直聘也要建，黑客松平台也要建。垂直不同，但骨架相同。

**通爻产品**只需定义三样东西：

1. **Scene 定义** — 谁参与、什么上下文、Template 收集什么
2. **UI Shell** — 用户怎么表达需求、怎么看到结果
3. **领域定制（可选）** — 自定义 formulation 插件、自定义结果展示

其余全部由协议层提供：
- 匹配算法 → HDC 共振
- 协调逻辑 → Center Agent
- 递归/缺口处理 → 协商单元递归
- 反馈/评价 → 回声信号
- 推荐改进 → Profile 演化 → 重新投影
- 支付 → WOWOK Machine/Treasury
- 可观测性 → 追溯链 JSON log

---

## 产品开发者的角色变化

- **传统**：产品开发者 = 工程师（写代码、建系统）
- **通爻**：产品开发者 = **场景设计师**（定义上下文）

场景设计师不需要会编程。他需要理解：
- 这个场景里的人有什么特点？
- 他们的需求是什么样的？
- 什么样的匹配是好的？
- 结果应该怎么呈现？

这些都是业务问题，不是技术问题。

---

## 协商单元 API 边界

"API 边界"= 产品层和协议层之间的分界线。线以上产品开发者管，线以下协议管。开发者不需要知道 HDC、Center、共振检测等任何内部机制。

### 产品层 → 协议层（调用方向）

| API | 作用 |
|-----|------|
| `create_scene(config)` | 创建场景 |
| `register_agent(scene_id, profile_data)` | 注册 Agent |
| `submit_demand(scene_id, user_id, intent)` | 提交需求 |
| `confirm_formulation(demand_id, confirmed_text)` | 确认丰富化后的需求 |
| `user_action(negotiation_id, action)` | 用户对方案的操作 |

### 协议层 → 产品层（事件推送，全量）

| 事件 | 数据 |
|------|------|
| `formulation.ready` | 丰富化结果 |
| `resonance.activated` | 激活的 Agent 数量 + 共振分数 |
| `offer.received` | 单个 Offer（逐个推送） |
| `barrier.complete` | Offer 收集完毕 |
| `center.tool_call` | Center 的工具调用 |
| `plan.ready` | 最终方案 |
| `sub_negotiation.started` | 子协商启动 |
| `execution.progress` | 执行进展 |
| `echo.received` | 回声信号 |

**设计原则**：事件流全量推送，产品层自行选择展示哪些。我们有什么就展示什么。

---

## 场景的生命周期定位

**创始人的关键判断**：场景是前期的商业工具，不是永久的架构概念。

```
V1: 场景（手动，组织者运营）→ 获客 + 数据积累 + 价值证明
V2: Service Agent 聚类 → 市场自然涌现
V3: 场景溶解 → 开放网络 + 市场 → 响应范式完全体
```

场景存在的目的：
1. 商业入口（单点突破）
2. 数据收集（Template → 丰富 Profile）
3. 价值证明（每个成功场景 = 案例）

市场不是设计出来的，是从重复交互中涌现的（Section 1.4）。

---

## 进阶洞察：场景即 Agent

> V2+ 探索方向，V1 不实现。

如果投影是基本操作（设计原则 0.8），场景本身也可以被投影为 HDC 向量：

```
Agent  = 人的投影
Scene  = 上下文的投影
Demand = 张力的投影

全部都是投影。全部参与同一个共振场。
```

这意味着：
- 用户不搜索场景，合适的场景自己浮现（响应范式应用到场景发现本身）
- 场景之间也可以共振（一个场景的缺口触发跟另一个场景的关联）
- 场景可以从交互中涌现，不需要组织者手动创建

**V1 策略**：数据结构预留兼容性（场景有 HDC 向量字段），但不实现场景共振。

---

## 协议层学习机制

**两层反馈循环**：

```
第一层：Agent 层面（已设计）
  协作结果 → 回声 → Profile 更新 → 下次匹配更好

第二层：协议层面（新课题）
  多个场景的运行数据 → 协议参数自己优化
```

跨场景追溯链聚合可以学到的：
- 某类场景的最优 k* → 推荐默认值
- 哪些 formulation 追问模式有效 → 改进默认策略
- Center 工具调用模式 → 优化 prompt
- **失败的场景（最有价值的信号）** → 识别协议的薄弱点

**关键**：失败比成功更有价值。追溯链结构（Section 11.7）已支持事后分析。"协议怎么从分析中自动改进"是 V2+ 课题。

---

## 创始人的核心提醒

> "你说的那些都很美，但我们之前连一次都没跑通过。是不是太理想了？"

这个提醒非常重要。架构讨论的 14 个 Task 全部完成，设计原则 12 条，文档 2000+ 行——但零次端到端运行。

**所有设计都还是假设。** 下一步不是继续设计，而是跑通第一个完整闭环。

---

*写于架构讨论转向实现的转折点。*
*想得再清楚，不如跑一次。*
